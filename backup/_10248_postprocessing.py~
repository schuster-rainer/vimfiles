
VERSION = '2009-07-09'

import os
import time

def ErrorMsg(escape=0):
    """
    returns: string

    simualtes the traceback output and if argemument
    <escape> set to 1 (true) the string will be
    converted to fit into html documents without problems.    
    """
    import traceback, sys, string

    type=None
    value=None
    tb=None
    limit=None
    type, value, tb = sys.exc_info()
    body = "Traceback (innermost last):\n"
    list = traceback.format_tb(tb, limit) + traceback.format_exception_only(type, value)
    body = body + "%-20s %s" % (
        string.join(list[:-1], ""),
        list[-1],
    )
    if escape:
        import cgi
        body = cgi.escape(body)
    return body


def PositionToMsg(position):

    try:

    #print ""
    #for i in range(1,97):
        #strip_num = ((i-1)//8)+1
        #strip_pos = chr(ord('A')+((i-1)%8))
        #print i, ">>", "%02i-%s" % ( strip_num, strip_pos )  

        i = int(position) 

        strip_num = ((i-1)//8)+1
        strip_pos = chr(ord('A')+((i-1)%8))

        s = "%02i (%02i-%s)" % ( i, strip_num, strip_pos ) 

    except:
        s = '-?-'
    return s

def PositionToMsgEx(dic):
    # ! Position ist ein MUSS !
    key = 'position'
    if dic.has_key(key):
        msg = PositionToMsg( dic[key] )
    else:
        msg = '---'
    return msg            




def KeyToMsg_A(dic,key):
    if dic.has_key(key):
        msg = dic[key]
    else:
        msg = '---'
    return msg


# ! Pfad uebergaben

def Postprocessing_A(path_test, dicInfo_test, dicInfo_run, dicFilter_test={}, dicFilter_run={}):

    # TBD Set Database for patternmatching

    if 1:
        #print 3*'\n', 20*'*'
        print path_test

    if 1:
        import _10248_assayrules as assayrules
        import _10248_html as html_tools
        import pickle


        ###########################################################################################################
        ## hier aktuelle db eintragen , tbd konfigurierbar !

        #fn_db = '_10248_StauDB_2009-01-20a.db'
        #fn_db = '_10248_StauDB_2009-06-17a.db'
        #fn_db = '_10248_StauDB_2009-06-17b.db'
        fn_db = '_10248_StauDB_2009-07-02c.db'

        fn_dump = '_10248_Page_B_20090707_01.dump' # fuer Seite B

        ###########################################################################################################

        fpRaw = os.path.join(path_test, 'result.txt')
        fpHtml_A = os.path.join(path_test, 'result.res.html')
        fpHtml_B = os.path.join(path_test, 'result_B.res.html')

        fp_reference_db = os.path.join( os.path.dirname(os.path.abspath(__file__)), fn_db)
        dic_rules_result = assayrules.iMainRules_A(fpRaw, fp_reference_db)

        fp_dump = os.path.join( os.path.dirname(os.path.abspath(__file__)), fn_dump)	

        #--


        for key in dicFilter_test:
            # has filter the excepted key ?
            if not dicInfo_test.has_key(key): return # tbd
            # has filter the excepted value ?
            if not dicInfo_test[key] == dicFilter_test[key]: return #TBD

            if 0:
                print 'FILTER ok:', 'key:', key, 'expected value:', dicFilter_test[key]



        # die folgende Formatierung auslagern
        # ---
        mode = 3
        if mode == 3:

            ## -- Beginn: Fuer alle pages --
            ## Die Header-Infos muessen auf alle pages

            Report_A = html_tools.HtmlPage_A(fpHtml_A)
            Report_B = html_tools.HtmlPage_A(fpHtml_B)


            Report_A.Add_BadBox( 'For Investigational Use Only. Not Intended for Use in Clinical Diagnostics.' )
            Report_A.Add_Heading('StaphyType Test Report', 5)

            Report_B.Add_BadBox( 'For Investigational Use Only. Not Intended for Use in Clinical Diagnostics.' )
            Report_B.Add_Heading('StaphyType Test Report (2nd Page)', 5)



            lst_ExpInfo = [('Operator',         KeyToMsg_A(dicInfo_test, 'operator') ),    # TBD: mit in dic Info Test
                           ('Sample ID',        KeyToMsg_A(dicInfo_test, 'sampleID') ),
                           ('Experiment ID',    os.path.basename(path_test)          ),
                           ('Date of Result',   time.asctime()                       ),
                           ('Assay Name',       'StaphyType'                         ),
                           ('Assay ID',         KeyToMsg_A(dicInfo_test, 'assayID')  ),
                           ('Well Position',    PositionToMsgEx(dicInfo_test)        ),
                           ('Software Version', VERSION                              ),    # lt. Ralf L. werden Device SW und IconoVersion nicht extra aufgefuerhrt
                           ('Device',           KeyToMsg_A(dicInfo_test, 'deviceID') ),    # TBD 
                           ]

            Report_A.Add_Table_A(lst_ExpInfo)
            Report_B.Add_Table_A(lst_ExpInfo)

            try:

                Report_A.Add_Heading('Internal Controls')

                show_affiliation = False
                show_genotypes = False
                #page b tbd -> code cleaning
                show_page_b_details = False


                if dic_rules_result['processed_check'] == False:  #TBD: nach vorn uber spots, nicht substancen !
                    Report_A.Add_BadBox('Please check this array was proccessed!') # Wie ?
                #elif: zu viele invalide spots
                else:
                    # dic_rules_result['biotin_check']  ->  'OK','ERR', None
                    # ist laut Ralf kein Abbruchkriterium

                    # Entscheidung von Ralf: ->> nach rules !
                    # dic_rules_result['markers_check']  ->  'USABLE', 'LIMITED', 'UNUSABLE', None
                    if dic_rules_result['markers_check'] == 'LIMITED':
                        dic_rules_result['markers_check'] = 'USABLE'


                    # erst nach Umdeutung !, Achtung, wenn dic_rules_result als self variable !
                    Report_A.Add_segment_Controls(dic_rules_result)
                    Report_B.Add_segment_Controls(dic_rules_result)

                    #if dic_rules_result['markers_check'] in 'USABLE', 'LIMITED':
                    if dic_rules_result['markers_check'] == 'USABLE':

                        Report_A.Add_Heading('Genetic markers for S. aureus / MRSA / PVL')
                        Report_B.Add_Heading('Genetic markers for S. aureus / MRSA / PVL')

                        # nur zur Sicherheit:
                        if dic_rules_result.has_key('genus'):
                            classification_genus = dic_rules_result['genus']
                        else:                
                            classification_genus = None
                        if dic_rules_result['dicSpecies_check'].has_key('s_aureus'):
                            classification_s_aureus = dic_rules_result['dicSpecies_check']['s_aureus']
                            show_affiliation = True
                        else:                
                            classification_s_aureus = None
                        if dic_rules_result['dicResistances'].has_key('mecA'):
                            classification_mecA = dic_rules_result['dicResistances']['mecA']['classification'] 
                        else:                
                            classification_mecA = None
                        if dic_rules_result['dicVirulences'].has_key('PVL'):
                            classification_PVL = dic_rules_result['dicVirulences']['PVL']['classification']
                        else:                
                            classification_PVL = None

                        if classification_s_aureus == 'POSITIVE':  # es gibt nur ['POSITIVE', 'NEGATIVE']
                            # !! unabhaengig von genusmarker, da dieser nur auf einer Sonde basiert, s_aur aber auf 10
                            # Achtung: bisher im Regelwerk genus bedingung fuer aureus !! -> somit hier 
                            msg_taxonomy = 'Species Marker (<i>S.aureus</i>) <font size=2 color="#FF0000"><b>positive</b> </font>'
                            msg_taxonomy = msg_taxonomy + '<BR>&nbsp;' # Neu
                            show_affiliation = True
                            show_genotypes = True

                        elif classification_genus == 'POSITIVE':   # es gibt nur ['POSITIVE', 'NEGATIVE']
                            msg_taxonomy = 'Genus Marker <i>Staphylococcus</i> (23SrRNA) <font size=2 color="#FF0000"><b>positive</b> </font>' # ?? negativ ?
                            # wunsch Peter: Bei nur Genus explizit noch einmasl daruf hinweisen, dass kein Stau
                            # sinnvoll da Typing jetzt weiter unten steht !
                            msg_taxonomy = msg_taxonomy + ',<BR>&nbsp;Species Marker (<i>S.aureus</i>) <font size=2 color="#FF0000"><b>negative</b> </font>'

                            show_genotypes = True
                        else:
                            msg_taxonomy = '<b>failed</b>'
                            classification_mecA = None
                            classification_PVL = None
                            show_genotypes = False



                        lst_A = [('Taxonomy',       msg_taxonomy),
                                 ('MRSA (mecA)',    html_tools.trans_Classification[classification_mecA]),
                                 ('PVL',            html_tools.trans_Classification[classification_PVL]),
                                 ]
                        Report_A.Add_Table_A(lst_A)
                        Report_B.Add_Table_A(lst_A)

                        show_page_b_details = show_genotypes # Uebernehmen

                        ## -- Beginn: Fuer alle pages --
                        ## ---

                        #x = 1/0 # Test

                        # add page break

                        Report_A.Add_Heading('Resistance Genotype')			
                        Report_A.Add_Table_Genotype_Resistances(dic_rules_result['dicResistances'])

                        Report_A.Add_Heading('Virulence Genotype')
                        Report_A.Add_Table_Genotype_Virulences(dic_rules_result['dicVirulences'])

                        Report_A.Add('<BR>')

                        # Falsch
                        #Report_A.Add_BadBox( 'The results listed below have not been cleared <BR>&nbsp;by the Food and Drug Administration for In Vitro Diagnostic Use. <BR>&nbsp;These values are provided for Research Use Only.' )
                        # Spaeter (nach Zulassung):
                        #Report_A.Add_BadBox( 'The results listed below have not been cleared for In Vitro Diagnostic Use. <BR>&nbsp;These values are provided for Research Use Only.' )
                        # z.Zt.
                        Report_A.Add_BadBox( '&nbsp;<BR>&nbsp;' )

                        Report_A.Add_Heading('Typing and Strain Affiliation')
                        if show_affiliation:
                            Report_A.Add_segment_Typing(dic_rules_result)
                        else:
                            Report_A.Add_BadBox('No <i>S.aureus</i>')            

            except:

                Report_A.Add( '<br><br>ERROR:<br>')
                Report_A.Add( ErrorMsg(1) )

            Report_A.Save()



        if show_page_b_details: ## Page 2

            f_dump = file(fp_dump, 'r')
            lst_pagelike = pickle.load(f_dump)
            f_dump.close()

            ### Neu tom fuer Page 2:
            dic_substances = dic_rules_result['dic_substances'] 
            dic_substances_classified = dic_rules_result['dic_substances_classified'] 

            for e in lst_pagelike:
                Report_B.Add_Heading(e['Typ']) # Einzahl vs. Mehrzahl !

                lst_order = []
                dic_Geno_results = {} 

                for row_dic in e['row_dics']:
                    lst_order.append(row_dic) 
                    rtv = {}
                    #print '>>\t', row_dic['RuleType']
                    dicFactors = { row_dic['key']: {'substances': row_dic['substances']} }


                    try:
                        #xxx =  assayrules.ClassifyFactors_Simple_A( { row_dic['key']: {'substances': row_dic['substances']} }, dic_substances_classified )

                        # ok .. geht auch noch generischer via exec
                        # ClassifyFactors_Simple_A
                        # CalculateAndClassifyMarkerSignals
                        # ClassifyFactors_Special_tst
                        # ClassifyFactors_Special_ecg
                        # ClassifyFactors_Special_hlb     # neu! ! TBD  # nur wenn beide positiv dann pos.		

                        # ClassifyFactors_Special_ACME

                        # ClassifyFactors_Special_agr     # neu   Regel: median bilden und mit allen anderen agrd vergleichen
                        # ClassifyFactors_Special_mecR    # neu   Regel: wenn beide da, dann gen da, wenn nur 611 und nicht 612 da order nur 612 da, dann komplett da
                        #                                   --> wo ist da der Unterschied zu simple A ??
                        # ClassifyFactors_Special_cap    # neu   Regel groesser gleich 2 positiv - positiv			

                        # Typ : def ClassifyFactors_xxx(dicFactors, dic_substances_classified):
                        # ClassifyFactors_Simple_A
                        # ClassifyFactors_Special_ecg
                        # ClassifyFactors_Special_ACME
                        # ClassifyFactors_Special_tst     # nutzt Parameter nicht wirklich

                        if row_dic['RuleType'] == 'ClassifyFactors_Simple_A':
                            rtv =  assayrules.ClassifyFactors_Simple_A( dicFactors, dic_substances_classified ) 
                        elif row_dic['RuleType'] == 'ClassifyFactors_Special_ecg':
                            rtv =  assayrules.ClassifyFactors_Special_ecg( dicFactors, dic_substances_classified ) 
                        elif row_dic['RuleType'] == 'ClassifyFactors_Special_ACME':
                            rtv =   assayrules.ClassifyFactors_Special_ACME( dicFactors, dic_substances_classified ) 
                        elif row_dic['RuleType'] == 'ClassifyFactors_Special_tst':
                            rtv =  assayrules.ClassifyFactors_Special_tst( dicFactors, dic_substances_classified ) 

                        # 
                        # nutzen auch ClassifyFactors_Special_A:
                        #  def ClassifyFactors_Special_ecg(dicFactors, dic_substances_classified):
                        #    return ClassifyFactors_Special_A(dicFactors, dic_substances_classified, minPos = 4, maxNone = 3)    
                        # def ClassifyFactors_Special_ACME(dicFactors, dic_substances_classified):
                        #    return ClassifyFactors_Special_A(dicFactors, dic_substances_classified, minPos = 2, maxNone = 2)			    


                        elif row_dic['RuleType'] in ['ClassifyFactors_Special_cap',]:   # Regel groesser gleich 2 positiv - positiv

                            #rtv =  assayrules.ClassifyFactors_Special_A(dicFactors, dic_substances_classified, minPos = 2, maxNone = 3) # ! max subst == 5
                            rtv =  assayrules.ClassifyFactors_Special_B(dicFactors, dic_substances_classified, minPos = 2, maxNone = 3)  # ! max subst == 5

                        elif row_dic['RuleType'] in ['ClassifyFactors_Special_hlb',]: # nur wenn beide positiv dann pos.
                            #rtv =  assayrules.ClassifyFactors_Special_A(dicFactors, dic_substances_classified, minPos = 2, maxNone = 0) # ?
                            rtv =  assayrules.ClassifyFactors_Special_B(dicFactors, dic_substances_classified, minPos = 2, maxNone = 0)  


                        elif row_dic['RuleType'] in ['ClassifyFactors_both_must_plus',]: # nur wenn beide positiv dann pos.
                            #rtv =  assayrules.ClassifyFactors_Special_A(dicFactors, dic_substances_classified, minPos = 2, maxNone = 0) # ?
                            rtv =  assayrules.ClassifyFactors_Special_B(dicFactors, dic_substances_classified, minPos = 2, maxNone = 0)  

                        elif row_dic['RuleType'] in ['ClassifyFactors_Special_mecR',]:

                            if 1: # neu ausgelagert

                                # sammeln, bis alle von Ruletype-Block da
                                if not locals().get('dicBlock_mecR'):
                                    dicBlock_mecR = {}			    
                                dicBlock_mecR[row_dic['key']] = {}

                                # wenn alle da .. anwenden
                                if len(dicBlock_mecR) == 2: # Anzahl muss man wissen. Nicht so schlimm, da eh ganz speziell, geht auch generischer	

                                    # Block-Regel anwenden
                                    # rtv = assayrules.ClassifyFactors_Special_mecR(dicBlock_mecR, dic_substances_classified)
                                    rtv = assayrules.ClassifyFactors_Special_mecR({}, dic_substances_classified)

                                    # Aufraeumen
                                    dicBlock_mecR = {}  #.. oder del
                                else:
                                    rtv = {}

                            else:
                                rtv = {}

                        elif row_dic['RuleType'] in ['ClassifyFactors_Special_agr',]:

                            if not locals().get('lstBlock_agr'):
                                lstBlock_agr = []			    
                            lstBlock_agr.append(row_dic)

                            # wenn alle da .. anwenden
                            if len(lstBlock_agr) == 4: # Anzahl muss man wissen. Nicht so schlimm, da eh ganz speziell, geht auch generischer	

                                # Block-Regel anwenden	    
                                rtv = assayrules.ClassifyFactors_Special_TopOfBlock_A({}, 
                                                                                      dic_substances_classified, 
                                                                                      dic_substances, 
                                                                                      lstBlock_agr, 
                                                                                      threshold_minDiffToTop = 0.2)  
                                # Aufraeumen
                                lstBlock_agr = {}  #.. oder del
                            else:
                                rtv = {}			    




                        elif row_dic['RuleType'] in ['ClassifyFactors_Special_set1',]:

                            # sammeln, bis alle von Ruletype-Block da
                            if not locals().get('lstBlock_set1'):
                                lstBlock_set1 = []			    
                            lstBlock_set1.append(row_dic)

                            # wenn alle da .. anwenden
                            if len(lstBlock_set1) == 3: # Anzahl muss man wissen. Nicht so schlimm, da eh ganz speziell, geht auch generischer	

                                # Block-Regel anwenden	  
                                rtv = assayrules.ClassifyFactors_Special_TopOfBlock_A({}, 
                                                                                      dic_substances_classified, 
                                                                                      dic_substances, 
                                                                                      lstBlock_set1, 
                                                                                      threshold_minDiffToTop = 0.1)  
                                # Aufraeumen
                                lstBlock_set1 = {}  #.. oder del
                            else:
                                rtv = {}


                        elif row_dic['RuleType'] in ['ClassifyFactors_Special_set4',]:

                            # sammeln, bis alle von Ruletype-Block da
                            if not locals().get('lstBlock_set4'):
                                lstBlock_set4 = []			    
                            lstBlock_set4.append(row_dic)

                            # wenn alle da .. anwenden
                            if len(lstBlock_set4) == 3: # Anzahl muss man wissen. Nicht so schlimm, da eh ganz speziell, geht auch generischer	

                                # Block-Regel anwenden	  
                                rtv = assayrules.ClassifyFactors_Special_TopOfBlock_A({}, 
                                                                                      dic_substances_classified, 
                                                                                      dic_substances, 
                                                                                      lstBlock_set4, 
                                                                                      threshold_minDiffToTop = 0.1)  
                                # Aufraeumen
                                lstBlock_set4 = {}  #.. oder del
                            else:
                                rtv = {}

                    except:
                        print "ERROR:row_dic:" #, row_dic

                    for k in rtv: #  seit Bloecken nicht mehr nur einer!
                        dic_Geno_results[k] = rtv[k]




                #self.Add_Table_Genotype(dic_Geno_results, resistances_order, column_names)
                if e['Typ'] == 'set / ssl Genes':
                    column_names = {'hybridisation': 'Probe', 'result': 'Result', 'explanation': 'Explanation' } 
                else:
                    column_names = {'hybridisation': 'Gene/Probe', 'result': 'Result', 'explanation': 'Explanation' }
                    
                Report_B.Add_Table_Genotype(dic_Geno_results , lst_order = lst_order, column_names = column_names )


            Report_B.Save()


            #print dic_rules_result


            ##if type(val) == type({}):


        ##---------------------------------------------------------
        ## develop output !
        ##---------------------------------------------------------
        develop = False
        if develop: # aus config beziehen ! Muss z.Zt. schief gehen
            try:
                import _10248_postprocessing_tests 
                _10248_postprocessing_tests.main( locals(), globals() )
            except:
                pass




def Postprocessing(exp_path):

    pass


#-----------------------------

                    #dic_substances_classified = {}
                    #for substance in dic_substances:
                        #dic_substances_classified[substance] = dic_substances[substance]['classification']		    


                                #dicResistances_A = {'aadD' : {'substances':['1,2-aadD',]},
                                #'mupR' : {'substances':['13,2-mupR',]},
                                        #'msrA' : {'substances':['15,3-msrA',]},
                                        #'vatA' : {'substances':['15,3-vatA',]},

                                #virulences_order = [ {'key': 'tst',         'name': 'tst-1',     'description': 'Toxic Shock Syndrome Toxin'},
                                                        #{'key': 'tst(bovin)',  'name': 'tst-RF122', 'description': 'Toxic Shock Syndrome Toxin, allele from bovine strains'}, # 'tst-1 (bovine)'
                                                        #{'key': 'entA',        'name': '',          'description': 'Enterotoxin A'},
                                                        #{'key': 'entB',        'name': '',          'description': 'Enterotoxin B'},
